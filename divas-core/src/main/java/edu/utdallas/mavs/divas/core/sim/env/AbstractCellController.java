package edu.utdallas.mavs.divas.core.sim.env;

import java.awt.geom.Rectangle2D;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentLinkedQueue;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.jme3.math.Vector3f;

import edu.utdallas.mavs.divas.core.client.dto.CellStateDto;
import edu.utdallas.mavs.divas.core.host.Host;
import edu.utdallas.mavs.divas.core.msg.RemoveEventMsg;
import edu.utdallas.mavs.divas.core.msg.RemoveStateMsg;
import edu.utdallas.mavs.divas.core.msg.RuntimeAgentCommandMsg;
import edu.utdallas.mavs.divas.core.sim.agent.Agent;
import edu.utdallas.mavs.divas.core.sim.common.event.EnvEvent;
import edu.utdallas.mavs.divas.core.sim.common.percept.AudioPerceptor;
import edu.utdallas.mavs.divas.core.sim.common.percept.Destructive;
import edu.utdallas.mavs.divas.core.sim.common.percept.SmellPerceptor;
import edu.utdallas.mavs.divas.core.sim.common.percept.VisionPerceptor;
import edu.utdallas.mavs.divas.core.sim.common.state.AgentState;
import edu.utdallas.mavs.divas.core.sim.common.state.CellState;
import edu.utdallas.mavs.divas.core.sim.common.state.EnvObjectState;
import edu.utdallas.mavs.divas.core.sim.common.state.VirtualState;
import edu.utdallas.mavs.divas.core.sim.common.stimulus.AgentStimulus;
import edu.utdallas.mavs.divas.core.sim.common.stimulus.Stimuli;
import edu.utdallas.mavs.divas.mts.CommunicationModule;
import edu.utdallas.mavs.divas.mts.DivasTopic;
import edu.utdallas.mavs.divas.mts.MTSException;
import edu.utdallas.mavs.divas.mts.MTSPayload;
import edu.utdallas.mavs.divas.utils.Multithreader;
import edu.utdallas.mavs.divas.utils.Multithreader.ThreadPoolType;

/**
 * This is the abstract base class for the cell controller.
 * <p>
 * The virtual space is partitioned into smaller areas that are managed autonomously in a decentralized manner by the cell controllers.
 * <p>
 * A cell controller is required to: 1) autonomously manage environmental information about its cell. 2) be aware of the virtual agents located in its defined area. 3) be able to interact with local virtual agents to inform them about changes in
 * their surroundings. 4) be able to communicate with other cell controllers to inform them of external events.
 * 
 * @param <E>
 *        Environment
 */
public abstract class AbstractCellController<E extends Environment<?>> implements CellController, Serializable
{
    private static final long                               serialVersionUID = 1L;

    private static final Logger                             logger           = LoggerFactory.getLogger(AbstractCellController.class);

    /**
     * The environment
     */
    protected transient E                                   environment;

    /**
     * A map that stores agent ID along with agent state.
     */
    protected Map<Integer, Agent>                           agents;

    /**
     * The cell controller State.
     * 
     * @see edu.utdallas.mavs.divas.core.sim.common.state.CellState
     */
    protected CellState                                     cellState;

    /**
     * The communication module that handles the connection to the message broker server.
     */
    protected transient CommunicationModule                 comModule;

    /**
     * A list of agent stimulus. This represents the agents stimulus generated after executing the agent phase. Each
     * stimulus represents agent intention to do something.
     * 
     * @see edu.utdallas.mavs.divas.core.sim.common.stimulus.AgentStimulus
     */
    protected List<AgentStimulus>                           agentStimuli;

    /**
     * A Queue for storing external stimulus. External stimulus is stimulus that is not generated by the cell controller
     * but it affects its contents. It used to represent cell controller merges or
     * splits, agent modifications or removes, environment object modifications or removes.
     * edu.utdallas.mavs.divas.sim.env.ExternalStimulus
     */
    protected ConcurrentLinkedQueue<ExternalStimulus>       externalStimuliBuffer;

    /**
     * A queue for storing user commands. User commands is generated when user controls an agent at runtime.
     * 
     * @see edu.utdallas.mavs.divas.core.msg.RuntimeAgentCommandMsg
     */
    protected ConcurrentLinkedQueue<RuntimeAgentCommandMsg> userCommandBuffer;

    /**
     * A multithreader to provide a standard mechanism for developer to handle concurrent programming.
     */
    protected static Multithreader                          multithreader;

    /**
     * Constructs the cell controller by assigning the cell state and the environment to the cell controller and
     * initializing the lists and maps and creating a multithreader.
     * 
     * @param cellState
     *        Cell state which specify the cell controller characteristics.
     * @param environment
     *        Environment where the cell controller resides.
     */
    public AbstractCellController(CellState cellState, E environment)
    {
        this.cellState = cellState;
        this.environment = environment;
        agents = Collections.synchronizedMap(new HashMap<Integer, Agent>());
        agentStimuli = Collections.synchronizedList(new ArrayList<AgentStimulus>());
        externalStimuliBuffer = new ConcurrentLinkedQueue<ExternalStimulus>();
        userCommandBuffer = new ConcurrentLinkedQueue<RuntimeAgentCommandMsg>();

        if(multithreader == null || multithreader.isTerminated())
            multithreader = new Multithreader("CellCntrlThrd", ThreadPoolType.FIXED, 10, false);

    }

    /**
     * Constructs the cell controller by assigning the cell state, communication module and the environment to the cell
     * controller and initializing the lists and maps and creating a multithreader.
     * 
     * @param rootCellState
     *        Cell state which specify the cell controller characteristics.
     * @param comModule
     *        The communication module that handles the connection to the message broker server.
     * @param environment
     *        Environment where the cell controller resides.
     */
    public AbstractCellController(CellState rootCellState, CommunicationModule comModule, E environment)
    {
        this(rootCellState, environment);
        this.comModule = comModule;
    }

    /**
     * Creates a child cell controller of the given cell controller state.
     * 
     * @param state
     *        Cell state which specify the cell controller characteristics.
     * @return Child Cell controller for the given cell state.
     */
    protected abstract <CC extends CellController> CC createChild(CellState state);

    /**
     * Combines the agent stimulus and applying it on the agent states.
     * 
     * @return A list of <code>AgentStateModel</code> for agent states after applying agent stimulis.
     * @see edu.utdallas.mavs.divas.core.sim.env.AgentStateModel
     */
    protected abstract List<AgentStateModel> combineAgentStimuli();

    /**
     * Applies the user commands on the agent states.
     * 
     * @param cmd
     *        User command to be applied on the agent state.
     */
    protected abstract void applyUserCommand(RuntimeAgentCommandMsg cmd);

    /**
     * Creates an agent given the <code>AgentState</code>.
     * 
     * @param initialState
     *        <code>AgentState</code> for the agent to be created.
     * @return <code>VirtualAgent</code> for the agent created.
     */
    protected abstract Agent createAgent(AgentState initialState);

    /**
     * Process a destructive event.
     * <p>
     * Such an event can be one that causes injury to agents or damage to environment objects. *
     * 
     * @param event the destructive event
     */
    protected abstract void processDestructiveEvent(EnvEvent event);

    @Override
    public void deliberate(List<AgentStateModel> agentStates)
    {
        updateStates(agentStates);
        updateEvents();
        sendCellUpdateMsg();
    }

    /**
     * Update the <code>AgentStateModel</code> with the computed next state.
     * 
     * @param staticAgents
     *        List of <code>AgentStateModel</code> which represents agent current states.
     */
    protected void updateStates(List<AgentStateModel> staticAgents)
    {
        for(AgentStateModel agentStateModel : staticAgents)
        {
            // if the agent is leaving the cell, add to list to notify neighbors
            if(isLeavingCell(agentStateModel.getNextPosition()))
            {
                logger.debug("Agent {} leaving cell {} ", agentStateModel.getState().getID(), getCellID());

                if(!transferAgent(agentStateModel))
                {
                    agentStateModel.undoMove();
                }
            }
            else
            {
                if(!resolveConflicts(agentStateModel))
                {
                    agentStateModel.undoMove();
                }
            }

            // commit the agents new state
            agentStateModel.commitState();
        }
    }

    protected void updateEvents()
    {
        Iterator<EnvEvent> iter = cellState.getEvents().iterator();
        while(iter.hasNext())
        {
            EnvEvent event = iter.next();
            // if the event has expired, remove it
            if(event.hasExpired())
            {
                // iter.remove();
                cellState.removeEvent(event);
                sendRemoveEventMsg(event);
            }
            else if(contains(event.getOrigin()))
            {
                // propagates event across cells
                // optimization: only cell containing the event's origin transfer it
                if(!isLeavingCell(event.getBounds()))
                {
                    List<CellID> cells = environment.getCellMap().getCellsIntersecting(getCellID(), event.getBounds());
                    for(CellID cell : cells)
                    {
                        environment.getCellController(cell).addEvent(event);
                    }
                }
            }
        }
    }

    /**
     * Transfers the agent from the current cell controller to the cell controller that contains the next position of
     * the agent.
     * 
     * @param agentStateModel
     *        <code>AgentStateModel</code> of the the agent to be transfered.
     * @return boolean flag that indicates that the transfer process completed successfully.
     */
    protected boolean transferAgent(AgentStateModel agentStateModel)
    {
        Agent agent = getAgent(agentStateModel.getState().getID());
        CellController nextCellController = environment.getCellController(agentStateModel.getNextPosition());

        if(nextCellController != null)
        {
            if(nextCellController.resolveConflicts(agentStateModel))
            {
                nextCellController.addAgent(agent);
                removeAgent(agent.getId());
                return true;
            }
        }
        return false;
    }

    @Override
    public boolean resolveConflicts(AgentStateModel agentStateModel)
    {
        // AgentState state = agentStateModel.getState();
        boolean isCollisionResolved = true;

        // for each env obj state in the cell check whether it collides with the given state
        // for(EnvObjectState eo : cellState.getEnvObjects())
        // {
        // if(eo.isCollidable() && collides(agentStateModel.getNextBoundingArea(), eo.getBoundingArea()))
        // {
        // state.addCollision(new Collision(eo.getID(), CollisionType.ENVOBJ));
        // isCollisionResolved = false;
        //
        // logger.debug("Agent [{}] collides with envObj[{}]", state.getID(), eo.getID());
        // }
        // }

        // for each agent state in the cell check whether it collides with the given state

        // TODO: Disabled this testing until it matches with RVO agent path finding. (They assume agents have a radius, not a square. Our approaches need to match.)
        // for(AgentState agentState : cellState.getAgentStates())
        // {
        // if(state.getID() != agentState.getID())
        // {
        // if(collides(agentStateModel.getNextBoundingArea(), agentState.getBoundingArea()))
        // {
        // state.addCollision(new Collision(agentState.getID(), CollisionType.AGENT));
        // isCollisionResolved = false;
        //
        // logger.debug("Agent [{}] collides with agent[{}]", state.getID(), agentState.getID());
        // }
        // }
        // }
        return isCollisionResolved;
    }

    @Override
    public boolean hasConflicts(VirtualState state)
    {
        logger.debug("Checking collisions for {}[{}]", state.getModelName(), state.getID());
        state.updateBoundings();

        // for each env obj state in the cell check whether it collides with the given state
        for(EnvObjectState envObjectState : cellState.getEnvObjects())
        {
            if(state.getID() != envObjectState.getID())
            {
                if(collides(state, envObjectState))
                {
                    logger.debug("State [{}] collides with envObj[{}]", state.getID(), envObjectState.getID());
                    return true;
                }
            }
        }

        // for each agent state in the cell check whether it collides with the given state
        for(AgentState agentState : cellState.getAgentStates())
        {
            if(collides(state, agentState))
            {
                logger.debug("State [{}] collides with agent[{}]", state.getID(), agentState.getID());
                return true;
            }
        }
        return false;
    }

    /**
     * Determines if virtual state s1 collides with virtual state s2
     * <p>
     * To allow collision exceptions, override this method in child cell controllers. Sometimes it's useful to allow for collision exception by allowing the virtual states to break the environment rules.
     * 
     * @param s1
     *        The first <code>VirtualState</code> to be tested for collision.
     * @param s2
     *        The second <code>VirtualState</code> to be tested for collision.
     * @return true if s1 and s2 collide. Otherwise, false.
     */
    protected boolean collides(VirtualState s1, VirtualState s2)
    {
        // check whether two virtual states intersect each other
        if(!s1.equals(s2) && (s1.isCollidable() && s2.isCollidable()))
        {
            if(s1.getBoundingArea().intersects(s2.getBoundingArea()))
            {
                logger.debug("{} [{}] collides with {} [{}]", new Object[] { s1.getModelName(), s1.getID(), s2.getModelName(), s2.getID() });
                return true;
            }
        }
        return false;
    }

    @SuppressWarnings("unused")
    private boolean collides(Rectangle2D nextBoundingArea, Rectangle2D boundingArea)
    {
        if(nextBoundingArea.intersects(boundingArea))
        {
            return true;
        }
        return false;
    }

    /**
     * Publishes a message with the cell controller state to the subscribers.
     */
    public void sendCellUpdateMsg()
    {
        Runnable task = new Runnable()
        {
            @Override
            public void run()
            {
                CellStateDto data = new CellStateDto(cellState, Host.getHost().getCycles(), Host.getHost().getPeriod(), environment.getCellMap());
                sendMessage(new MTSPayload(0, data), DivasTopic.envTopic);
                logger.debug("Sent cell state update in cycle {} with {} agents, {} envObjects.", new Object[] { data.getCycleNumber(), data.getAgentStates().size(), data.getEnvObjects().size() });
            }
        };

        multithreader.execute(task);
    }

    /**
     * Publishes a message to the subscribers with the state to be removed.
     * 
     * @param state
     *        the state to be destroyed.
     */
    public void sendRemoveStateMsg(final VirtualState state)
    {
        Runnable task = new Runnable()
        {
            @Override
            public void run()
            {
                sendMessage(new MTSPayload(-1, new RemoveStateMsg(state)), DivasTopic.destroyEntityTopic);
                logger.debug("Sent a message to subscribers to destroy state {} ", new Object[] { state.getID() });
            }
        };

        multithreader.execute(task);
    }

    /**
     * Publishes a message to the subscribers with the state to be removed.
     * 
     * @param event the event to be destroyed
     */
    public void sendRemoveEventMsg(final EnvEvent event)
    {
        Runnable task = new Runnable()
        {
            @Override
            public void run()
            {
                sendMessage(new MTSPayload(-1, new RemoveEventMsg(event)), DivasTopic.destroyEntityTopic);
                logger.debug("Sent a message to subscribers to destroy state {} ", new Object[] { event.getID() });
            }
        };

        multithreader.execute(task);
    }

    @Override
    public void clearAgents()
    {
        agents.clear();
        cellState.clearAgents();
    }

    @Override
    public Agent getAgent(int agentId)
    {
        return agents.get(agentId);
    }

    @Override
    public Map<Integer, Agent> getAgents()
    {
        return agents;
    }

    @Override
    public void setAgents(Map<Integer, Agent> agents)
    {
        (this.agents).putAll(agents);
    }

    @Override
    public void removeAgent(int agentId)
    {
        agents.remove(agentId);
        cellState.removeAgent(agentId);
    }

    @Override
    public void removeEnvObject(EnvObjectState state)
    {
        cellState.removeEnvObject(state);
    }

    @Override
    public void addAgent(Agent agent)
    {
        agents.put(agent.getId(), agent);
        cellState.addAgent(agent.getState());
        logger.debug("Added agent {}[{}] in cell {}.", new Object[] { agent.getState().getModelName(), agent.getId(), getCellID() });
    }

    @Override
    public boolean addEnvObject(EnvObjectState eo)
    {
        return cellState.addEnvObject(eo);
    }

    @Override
    public boolean addEvent(EnvEvent e)
    {
        return cellState.addEvent(e);
    }

    @Override
    public CellID getCellID()
    {
        return cellState.getId();
    }

    @Override
    public CellState getCellState()
    {
        return cellState;
    }

    /**
     * Adds the given <code>AgentStimulus</code> to list of agent stimuli.
     * 
     * @param stimulus
     *        <code>AgentStimulus</code> to be added.
     */
    public void addAgentStimulus(AgentStimulus stimulus)
    {
        agentStimuli.add(stimulus);
    }

    @Override
    public void addExternalStimulus(ExternalStimulus extStimulus)
    {
        externalStimuliBuffer.add(extStimulus);
    }

    @Override
    public void addUserCommand(RuntimeAgentCommandMsg agCmd)
    {
        userCommandBuffer.add(agCmd);
    }

    @Override
    public boolean containsAgent(int agentID)
    {
        return cellState.containsAgent(agentID);
    }

    @Override
    public boolean containsEnvObject(int stateID)
    {
        synchronized(cellState.getEnvObjects())
        {
            for(VirtualState state : cellState.getEnvObjects())
                if(state.getID() == stateID)
                    return true;
            return false;
        }
    }

    /**
     * Publishes a message with the given payload and topic to the topic subscribers.
     * 
     * @param mtsPayload
     *        The message payload to be sent to subscribers of the topic.
     * @param topic
     *        The name of the topic on which the message will be sent.
     */
    protected void sendMessage(MTSPayload mtsPayload, String topic)
    {
        try
        {
            comModule.publishMessage(mtsPayload, topic);
        }
        catch(MTSException e)
        {
            logger.error("Cell controller {} could not send message {} at cycle {}.", new Object[] { getCellID(), topic, Host.getHost().getCycles() }, e);
        }
    }

    @Override
    public List<AgentStateModel> react()
    {
        cellState.setTime(Host.getHost().getCycles());

        combineExternalStimuli();

        processUserCommands();

        List<AgentStateModel> agentStates = combineAgentStimuli();

        processEvents();

        return agentStates;
    }

    /**
     * apply user commands to agents
     */
    private void processUserCommands()
    {
        RuntimeAgentCommandMsg cmd = null;
        while((cmd = userCommandBuffer.poll()) != null)
        {
            applyUserCommand(cmd);
        }
    }

    /**
     * combine external (user) stimuli to environment objects and agents
     */
    protected void combineExternalStimuli()
    {
        ExternalStimulus s = null;

        while((s = externalStimuliBuffer.poll()) != null)
        {
            applyExternalStimulus(s);
        }
    }

    /**
     * Applies the external stimulus on the agent states or the environment object states.
     * 
     * @param s
     *        ExternalStimulus to be applied.
     */
    protected void applyExternalStimulus(ExternalStimulus s)
    {
        // trigger events
        if(s.isEvent())
        {
            EnvEvent event = (EnvEvent) s.getStimulus();
            long tick = Host.getHost().getCycles();
            event.setEventOccurredTime(tick);
            cellState.addEvent(event);
            logger.debug("Added event {}[{}] to cell {}", new Object[] { event.getClass().getName(), event.getID(), getCellID() });
        }
        // create/destroy/modify agents
        else if(s.isAgent())
        {
            AgentState agent = (AgentState) s.getStimulus();
            switch(s.getCommand())
            {
            case CREATE:
                logger.debug("Adding agent {}[{}] to cell {}", new Object[] { agent.getModelName(), agent.getID(), getCellID() });
                Agent va = createAgent(agent);
                addAgent(va);
                break;
            case DESTROY:
                agent.setVisualized(false);
                removeAgent(agent.getID());
                sendRemoveStateMsg(agent);
                break;
            case MODIFY:
                updateRuntimeProperties(agent);
                break;
            default:
                break;
            }
        }
        // create/destroy/modify objects
        else if(s.isEnvObject())
        {
            EnvObjectState eo = (EnvObjectState) s.getStimulus();
            eo.updateBoundings();

            switch(s.getCommand())
            {
            case ADD:
                addEnvObject(eo);
                break;
            case CREATE:
                logger.debug("Adding env object {}[{}]to cell {}", new Object[] { eo.getModelName(), eo.getID(), getCellID() });
                addEnvObject(eo);
                break;
            case REMOVE:
                removeEnvObject(eo); // cellState.getEnvObjectState(eo.getID()));
                break;
            case DESTROY:
                eo.setVisualized(false);
                removeEnvObject(eo);
                sendRemoveStateMsg(eo);
                break;
            case MODIFY:
                EnvObjectState oldEnvObject = cellState.getEnvObjectState(eo.getID());
                logger.debug("old " + oldEnvObject.getPosition());
                logger.debug("new " + eo.getPosition());
                if(oldEnvObject != null)
                {
                    oldEnvObject.copyFrom(eo);
                }
                break;
            default:
                break;
            }
        }
    }

    protected void updateRuntimeProperties(AgentState agent)
    {
        // TODO Auto-generated method stub        
    }

    /**
     * Updates all kinds of events in the cell controller by executing events propagation and removing expired ones.
     */
    protected void processEvents()
    {
        Iterator<EnvEvent> iter = cellState.getEvents().iterator();
        while(iter.hasNext())
        {
            EnvEvent event = iter.next();

            // only cell controller containing the origin of the event needs to update it
            if(contains(event.getOrigin()))
            {
                // updates the current elapsed cycle of the event
                event.setAge(event.getAge() + 1);
                // propagates the event
                event.propagate();
            }

            // processes destructive properties of the event
            if(event instanceof Destructive)
            {
                processDestructiveEvent(event);
            }
        }
    }

    @Override
    public void executeAgents()
    {
        List<Runnable> tasks = new ArrayList<Runnable>();
        for(final Agent a : agents.values())
        {
            // Skip processing if the agent is dead
            if(!a.getState().isAlive())
                continue;

            Runnable task = new Runnable()
            {
                @Override
                public void run()
                {
                    // only execute if the agent has had time to get its first round of cell states
                    try
                    {
                        if(environment.hasCombinedPerceptionDataFor(a.getId()))
                        {
                            // retrieves the agent's perceivable environment (all perceivable cells merged together into
                            // one "environment")
                            CellState combinedCellState = environment.retrievePerceptionDataFor(a.getId());

                            // updates the agent's state according to the updated cell state
                            a.setState(combinedCellState.getAgentState(a.getId()));

                            // let the agent perceive its environment
                            a.perceive(combinedCellState);

                            // executes the agent, retrieving stimuli
                            Stimuli stimuli = a.execute();

                            if(stimuli != null && !stimuli.isEmpty())
                            {
                                stimuli.setCellID(getCellID());
                                stimuli.setTime(Host.getHost().getCycles());
                                agentStimuli.addAll(stimuli);
                            }
                        }
                    }
                    catch(Exception e)
                    {
                        logger.error("An error occurred while processing AGENT phase for {}", a.getId(), e);
                    }
                }
            };
            tasks.add(task);
        }
        multithreader.executeAndWait(tasks);
    }

    @Override
    public <CC extends CellController> List<CC> split()
    {
        logger.debug("Splitting Cell Controller: " + getCellID());
        ArrayList<CC> children = new ArrayList<CC>();

        CellState states[] = cellState.split();

        for(CellState state : states)
        {
            CC child = createChild(state);
            children.add(child);
        }

        for(Agent a : agents.values())
        {
            for(CC subCell : children)
            {
                if(subCell.getCellState().getBounds().contains(a.getState().getPosition()))
                {
                    children.get(children.indexOf(subCell)).addAgent(a);
                }
            }
        }

        // remove the agents from this cell controller
        clearAgents();

        // externalStimuli may not be empty in this phase, need to split
        ExternalStimulus stimulus = null;
        while((stimulus = externalStimuliBuffer.poll()) != null)
        {
            for(CC child : children)
            {
                if(child.getCellState().getBounds().contains(stimulus.getPosition()))
                {
                    child.addExternalStimulus(stimulus);
                    break; // leaves the for loop, not the case statement
                }
            }
        }

        // agentCommandBuffer may not be empty in this phase, need to split
        RuntimeAgentCommandMsg cmd = null;
        while((cmd = userCommandBuffer.poll()) != null)
        {
            AgentState agent = cellState.getAgentState(cmd.getAgentID());
            if(agent != null)
            {
                for(CC child : children)
                {
                    if(child.getCellState().getBounds().contains(agent.getPosition()))
                    {
                        child.addUserCommand(cmd);
                        break; // leave the for loop
                    }
                }
            }
        }

        return children;
    }

    @Override
    public void merge(CellController sibling)
    {
        logger.debug("Merging Cell Controllers: " + getCellID() + " : " + sibling.getCellID());

        agents.putAll(sibling.getAgents());
        getCellState().mergeWith(sibling.getCellState());

        // externalStimuli may not be empty, need to merge
        externalStimuliBuffer.addAll(sibling.getExternalStimuliBuffer());

        // userCommand may not be empty, need to merge
        userCommandBuffer.addAll(sibling.getUserCommandBuffer());

        logger.debug("Merged into: " + getCellID());
    }

    /**
     * Indicates if the given position is not in this cell controller.
     * 
     * @param nextPosition Position to be tested if it's in the cell controller.
     * @return boolean flag that indicates if the given position is not in the cell controller.
     */
    protected boolean isLeavingCell(Vector3f nextPosition)
    {
        return !contains(nextPosition);
    }

    /**
     * Indicates if the given position is contained by the cell controller.
     * 
     * @param position Position to be tested if it's in the cell controller.
     * @return boolean flag that indicates if the given position is in the cell controller.
     */
    protected boolean contains(Vector3f position)
    {
        return cellState.getBounds().contains(position);
    }

    /**
     * Indicates if the given area is not in this cell controller.
     * 
     * @param area area to be tested if it's in the cell controller.
     * @return boolean flag that indicates if the given position is not in the cell controller.
     */
    protected boolean isLeavingCell(Rectangle2D area)
    {
        return !cellState.getBounds().contains(area);
    }

    @Override
    public Collection<ExternalStimulus> getExternalStimuliBuffer()
    {
        return externalStimuliBuffer;
    }

    @Override
    public Collection<RuntimeAgentCommandMsg> getUserCommandBuffer()
    {
        return userCommandBuffer;
    }

    @Override
    public List<AgentStimulus> getAgentStimuli()
    {
        return agentStimuli;
    }

    @Override
    public int getAgentsCount()
    {
        return agents.size();
    }

    @Override
    public int getEnvObjectsCount()
    {
        return cellState.getEnvObjects().size();
    }

    // destroy this cell
    @Override
    public void destroy()
    {
        logger.debug("Destroying cell controller: " + getCellID());
        cellState.destroy();
        userCommandBuffer.clear();
        agentStimuli.clear();
        externalStimuliBuffer.clear();
        multithreader.terminate();
    }
}
